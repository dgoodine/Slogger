//
//  TextFileDestination.swift
//  Slogger
//
//  Created by David Goodine on 10/28/15.
//  Copyright Â© 2015 David Goodine. All rights reserved.
//

import Foundation

/** A rotating and archiving local filesystem destination.

 **Important**: This destination always keeps the file well-formed by outputting the postamble generated by
 `config.fileWrapperGenerator` after each entry.  Unless the app were to crash *while writing to the file*,
 it should always be assumed to be well formed.  This is particularly important for any formats that require
 content enclosing the entries (e.g. JSON and XML).

*/
open class TextFileDestination: DestinationBase, Destination {

  /// Configuration values for file destinations.
  open class Configuration {

    /**
     A closure that is called when a file is opened and before it is closed.

     - Parameter isPreamble: If `true` the file has just been opened.  If it is `false`, it is about to be closed.
     */
    public typealias FileWrapperGenerator = (_ isPreamble: Bool) -> String

    /**
     A closure that is called after a file has been closed.

     - Parameter path: The path of the file just closed.
     */
    public typealias PostFileCloseHandler = (_ path: String) -> Void

    /**
     A closure that is called after an archiving operation has completed.

     - Parameter archive: The recently compressed archive.
     */
    public typealias PostArchiveHandler = (_ directory: String) -> Void

    /// Time interval in seconds for log file rotation. Defaults to 24 hours.
    open var fileRotationInterval: TimeInterval = 60 * 60 * 24

    /// Time interval in seconds for log directory archiving.  Defaults to 7 days.
    open var directoryArchivingInterval: TimeInterval = 60 * 60 * 24 * 30

    /// Generator for prepending and appending text to a file. Defaults to nil.
    open var fileWrapperGenerator: FileWrapperGenerator? = nil

    /// Handler called after closing a file. Defaults to nil.
    open var postFileCloseHandler: PostFileCloseHandler? = nil

    /// Handler called after archiving. Defaults to nil.
    open var postArchiveHandler: PostArchiveHandler? = nil

    /// A string to emit between log entries.
    open var entryDelimiter: String = "\n"

    /// File extension for log files.  Defaults to "txt"
    open var fileExtension: String = "txt"

    /// Details to output.
    open var details: [Detail] = Detail.allValues

    /**
     File system attributes to use when creating the log directory and log files.

     - Warning: If you're developing for *iOS*, make sure you understand which directories are backed up to iCloud
     and either a) don't use them, or b) add the appropriate attributes so the log files aren't backed up. **If you
     don't, it's highly likely Apple will reject your binary when submitting to iTunes**.
     */
    open var fileAttributes: [String : AnyObject] = [:]

    /// Protocol property for Destination
    open var decorator: Decorator?

    /// Protocol property for Destination
    open var generator: Generator

    /// Protocol property for Destination
    open var colorMap: ColorMap?

    /**
     Constructor for TextFileDestination configuration.

     - Parameter generator: Generator to use for this destination.  If nil, uses the logger's generator.
     - Parameter colorMap: Colormap to use for this destination. If nil, uses the logger's colorMap.
     - Parameter decorator: Decorator to use for this destination.  If nil, uses the logger's decorator.
     */
    public init (details: [Detail] = Detail.allValues, generator: Generator, colorMap: ColorMap? = nil, decorator: Decorator? = nil) {
      self.details = details
      self.generator = generator
      self.colorMap = colorMap
      self.decorator = decorator
    }
  }

  // MARK: - Public
  /// Directory path for the log files.
  public let directory: String

  /// Configuration for this destination.
  public let config: Configuration

  /// Date the current output file was opened or nil if there's no output file open.
  open var outputFileDate: Date? {
    get {
      return _outputFileDate
    }
  }

  /// Path of the the current output file or nil if no file is open.
  open var outputFilePath: NSString? {
    get {
      return _outputFilePath as NSString?
    }
  }

  /**
   Designated initializer.

   - Parameter directory: Full path for the logging directory.  This will be created if necessary.
   - Parameter config: The configuration to use for this destination.  Defaults to `Configuration(generator: Generator())`.

   - SeeAlso: Configuration.fileAttributes for important information for iOS developers.
   */
  public init(directory: String, config: Configuration = Configuration(generator: Generator())) {
    self.directory = directory
    self.config = config
    super.init(details: config.details, generator: config.generator, colorMap: config.colorMap, decorator: config.decorator)
  }

  deinit {
    closeFile()
  }

  /// Protocol Implementation
  open func logString(_ string: String, level: Level) {
    if let os = outputFile {

      // Truncate the file to the current file position (to remove postamble that may have been output.
      var pos: fpos_t = 0
      fgetpos(os, &pos)
      truncate(_outputFilePath!, pos)

      let wrapper = config.fileWrapperGenerator
      let postamble = (wrapper == nil) ? "" : wrapper!(false)
      let postambleLength = postamble.lengthOfBytes(using: String.Encoding.utf8)
      let delimiter = (_outputFileEntryCount == 0) ?  "" : config.entryDelimiter
      let outputString = "\(delimiter)\(string)\(postamble)"

      // Output the entry
      fputs(outputString, os)
      fseek(os, -postambleLength, SEEK_END)

      // This could crash is we overflowed a UInt64. That would be a really big file.
      _outputFileEntryCount += 1
    }
  }

  // MARK: - Private

  /// Date format for log files
  fileprivate lazy var fileDateFormatter: DateFormatter = {
    let value = DateFormatter()
    value.dateFormat = "yyyy-MM-dd-HH-mm-ss-SSS-zzz"
    return value
  }()

  fileprivate var _outputFileDate: Date? = nil
  fileprivate var _outputFilePath: String? = nil
  fileprivate var _outputFileEntryCount: UInt64 = 0

  fileprivate var _outputFile: UnsafeMutablePointer<FILE>? = nil
  fileprivate var outputFile: UnsafeMutablePointer<FILE>? {
    get {
      if let fileOpenDate = _outputFileDate
        , _outputFile != nil && Date().timeIntervalSince(fileOpenDate) > config.fileRotationInterval {
          closeFile()
      }

      if _outputFile == nil {
        openFile()
      }

      return _outputFile
    }
  }

  /// Prevents error message spamming in the console.
  fileprivate var errorPrinted = false

  /// Utility function to open the logging file with the current date format
  fileprivate func openFile () {
    let fm = FileManager.default

    // Create the directory if it doesn't exist.
    if !fm.fileExists(atPath: directory) {
      do {
        try fm.createDirectory(atPath: directory, withIntermediateDirectories: true, attributes:convertToOptionalFileAttributeKeyDictionary(config.fileAttributes))
      } catch {
        if !errorPrinted {
          print("*** Fatal error in Slogger.TextFileDestination: \n\(error)")
          errorPrinted = true
        }
        return
      }
    }

    let now = Date()
    let dateString = fileDateFormatter.string(from: now)
    let filePath = "\(directory)/\(dateString).\(config.fileExtension)"
    guard fm.createFile(atPath: filePath, contents: Data(), attributes: convertToOptionalFileAttributeKeyDictionary(config.fileAttributes)) else {
      if !errorPrinted {
        print("*** Slogger.TextFileDestination couldn't create log file.")
        errorPrinted = true
      }
      return
    }

    _outputFileDate = now
    _outputFilePath = filePath

    let file = fopen(filePath, "w")

    if let wrapper = config.fileWrapperGenerator {
      let preamble = wrapper(true)
      let postamble = wrapper(false)
      let postambleLength = postamble.lengthOfBytes(using: String.Encoding.utf8)
      let initialContents = "\(preamble)\(postamble)"

      fputs(initialContents, file)
      fseek(file, -postambleLength, SEEK_END)
    }

    _outputFile = file
  }

  /// Close the current file descriptor and check for archiving.
  fileprivate func closeFile () {
    if _outputFile != nil {
      fclose(_outputFile!)
      _outputFile = nil
      _outputFileDate = nil
      _outputFilePath = nil
      _outputFileEntryCount = 0
      checkForArchiving()
    }
  }

  // Check existing log files for archiving.
  fileprivate func checkForArchiving () {
    // Not implemented.
  }
}

// Helper function inserted by Swift 4.2 migrator.
fileprivate func convertToOptionalFileAttributeKeyDictionary(_ input: [String: Any]?) -> [FileAttributeKey: Any]? {
	guard let input = input else { return nil }
	return Dictionary(uniqueKeysWithValues: input.map { key, value in (FileAttributeKey(rawValue: key), value)})
}
