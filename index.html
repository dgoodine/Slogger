<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Slogger : A simple, fast and flexible logging framework for Swift">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
    <script src="scripts.js" type="text/javascript"></script>

    <title>Slogger</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/dgoodine/Slogger">View on GitHub</a>

          <h1 id="project_title">Slogger</h1>
          <h2 id="project_tagline">A simple, fast and flexible logging framework for Swift</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/dgoodine/Slogger/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/dgoodine/Slogger/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h2>
<a id="why-another-swift-logging-framework" class="anchor" href="#why-another-swift-logging-framework" aria-hidden="true"><span class="octicon octicon-link"></span></a>Why Another Swift Logging Framework?</h2>

<p>When I started doing serious Swift development, I naturally looked around for a logging framework.  I found <em>XCGLogger</em> by Dave Wood <a href="https://github.com/DaveWoodCom" class="user-mention">@DaveWoodCom</a> (<a href="https://github.com/DaveWoodCom/XCGLogger">https://github.com/DaveWoodCom/XCGLogger</a>).  While it's fast and well constructed, I needed some extra features and decided to build my own.  But I did learn a few things from him so he deserves some props. <g-emoji alias="beer" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f37a.png">üç∫</g-emoji><g-emoji alias="beer" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f37a.png">üç∫</g-emoji><g-emoji alias="beer" fallback-src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f37a.png">üç∫</g-emoji></p>

<p><em>Slogger</em> uses much the same approach and identical function signatures as <em>XCGLogger</em>, so they are interchangeable without modifying existing logging sites. Be sure to check the <strong>Advanced Features</strong> section below ‚Äì particularly <em>Radioactive Logging</em> and <em>Categories</em> ‚Äì to see why I decided to go this route.</p>

<h2>
<a id="general-info" class="anchor" href="#general-info" aria-hidden="true"><span class="octicon octicon-link"></span></a>General Info</h2>

<h3>
<a id="logging-levels" class="anchor" href="#logging-levels" aria-hidden="true"><span class="octicon octicon-link"></span></a>Logging Levels</h3>

<p>The typical logger levels are supported:</p>

<pre><code>public enum Level : Int, Comparable {
  case None, Severe, Error, Warning, Info, Debug, Verbose

  static let allValues = [None, Severe, Error, Warning, Info, Debug, Verbose]
}
</code></pre>

<p>The order of the levels is higher-priority first. Thus the threshold is evaluated using the <em>&lt;=</em> operator. Here's the function that's used internally to determine if a message should be logged.  (See below for information on the <em>override</em> and <em>category</em> parameters.)</p>

<pre><code>  public func canLog (override override: Level?, category: T?, level: Level) -&gt; Bool {
    if override != nil {
      return (level == .None) ? false : level &lt;= override
    }

    if category != nil, let categoryLevel = categories[category!] {
      return level &lt;= categoryLevel
    }

    return level &lt;= activeLevel
  }
</code></pre>

<p>Note that the exception that specifying an <em>override</em> value of <em>.None</em> disables logging for the logging site.</p>

<h3>
<a id="creating-a-slogger-instance" class="anchor" href="#creating-a-slogger-instance" aria-hidden="true"><span class="octicon octicon-link"></span></a>Creating a <em>Slogger</em> Instance</h3>

<p>Setting up a logger can be as simple as one line of code:</p>

<pre><code>let log = Slogger&lt;NoCategories&gt;(defaultLevel: .Info)
</code></pre>

<p>And you'll likely want to tailor your build for debug/release:</p>

<pre><code>#if DEBUG
let log = Slogger&lt;NoCategories&gt;(defaultLevel: .Info)
#else
let log = Slogger&lt;NoCategories&gt;(defaultLevel: .Warning)
#endif 
</code></pre>

<p>The public interface is fully documented in the headers for reference in <em>Xcode</em> (use Alt-Click).  See the Docs directory for an HTML-based version.  (At some point there will be a docset available, but at the moment there are issues with both Jazzy and AppleDoc that I haven't had time to resolve.)</p>

<p>The <em>Slogger</em> class is generic to support categories, as explained below.</p>

<h3>
<a id="logging-site-functions" class="anchor" href="#logging-site-functions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Logging Site Functions</h3>

<p>Each log level has <em>autoclosure</em> and <em>noescape</em> trailing closure implementations, so the following are both valid forms:</p>

<pre><code>log.debug("Enter")
log.debug() { "Enter" }
</code></pre>

<p><strong>Important Note</strong>: The resulting closures <strong>are not evaluated if the logging site doesn't pass the level threshold</strong>.  So don't worry about expensive computations inside them.  And don't rely on them for side-effects.</p>

<p>For completeness, functions are provided for the .None level that have no-op implementations.  Thus the only overhead would be allocating the closure on the stack and the function call.</p>

<pre><code>log.none("Enter")
log.none() { "Enter" }
</code></pre>

<h3>
<a id="log-instance-properties" class="anchor" href="#log-instance-properties" aria-hidden="true"><span class="octicon octicon-link"></span></a>Log Instance Properties</h3>

<p>The following properties of each log instance are exposed and have read/write access.  They can be modified at runtime, either programmatically or by using the debugger at a breakpoint.</p>

<table>
<thead>
<tr>
<th>Property</th>
<th>Type</th>
<th>Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td>level</td>
<td>Level</td>
<td>The active, global level of the logger instance.</td>
</tr>
<tr>
<td>dateFormatter</td>
<td>NSDateFormatter</td>
<td>Formatter to use for dates.</td>
</tr>
<tr>
<td>details</td>
<td>[Detail]</td>
<td>Determines what to output and in what order.</td>
</tr>
<tr>
<td>categories</td>
<td>[T : Level]</td>
<td>A mapping between categories and levels (see below)</td>
</tr>
<tr>
<td>generator</td>
<td>Generator</td>
<td>Current generator.  Defaults to <em>defaultGenerator</em>.</td>
</tr>
<tr>
<td>destinations</td>
<td>[Destination]</td>
<td>Destinations this logger will write to.  Defaults to [<em>consoleDestination</em>].</td>
</tr>
<tr>
<td>colorMap</td>
<td>ColorMap</td>
<td>The current colorMap.</td>
</tr>
<tr>
<td>defaultGenerator</td>
<td>Generator</td>
<td>Default generator implementation.</td>
</tr>
<tr>
<td>consoleDestination</td>
<td>Destination</td>
<td>The default console implementation with an XCodeColors/ANSI decorator.</td>
</tr>
<tr>
<td>hits</td>
<td>UInt64</td>
<td>Number of events logged.</td>
</tr>
<tr>
<td>misses</td>
<td>UInt64</td>
<td>Number of events not logged due to logging threshold evaluation.</td>
</tr>
</tbody>
</table>

<p><strong>Important Note</strong>: <em>Slogger</em> instances are inherently thread-safe, as are all supported implementations of <em>Slogger</em> types and protocols.  If you provide an implementation for a protocol, it <strong>MUST</strong> be thread-safe as well.</p>

<h2>
<a id="advanced-features" class="anchor" href="#advanced-features" aria-hidden="true"><span class="octicon octicon-link"></span></a>Advanced Features</h2>

<h3>
<a id="destinations" class="anchor" href="#destinations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Destinations</h3>

<p>The <em>Destination</em> protocol allows you to write your own log destinations and add them to the logger. The following destinations are provided:</p>

<table>
<thead>
<tr>
<th>Destination</th>
<th>Status</th>
</tr>
</thead>
<tbody>
<tr>
<td>Console</td>
<td>Supported</td>
</tr>
<tr>
<td>Memory</td>
<td>Supported</td>
</tr>
<tr>
<td>File</td>
<td>Coming Soon‚Ñ¢</td>
</tr>
<tr>
<td>Network</td>
<td>Planned but no ETA</td>
</tr>
</tbody>
</table>

<h3>
<a id="generators" class="anchor" href="#generators" aria-hidden="true"><span class="octicon octicon-link"></span></a>Generators</h3>

<p>These are closures that output a log entry based on information from the logging site. They are configurable per logging destination.  You can use the provided generators or implement your own.</p>

<p>The default uses the typical pattern:</p>

<pre><code>- [10/25/2015, 15:33:57.435 EDT] SloggerTests.swift:117 callIt [] Severe: Message...
</code></pre>

<p>List of supported generators (see the source for details):</p>

<table>
<thead>
<tr>
<th>Generator</th>
<th>Status</th>
</tr>
</thead>
<tbody>
<tr>
<td>defaultGenerator</td>
<td>Supported</td>
</tr>
<tr>
<td>jsonGenerator</td>
<td>Coming Soon‚Ñ¢</td>
</tr>
<tr>
<td>xmlGenerator</td>
<td>Coming Soon‚Ñ¢</td>
</tr>
<tr>
<td>tabGenerator</td>
<td>Coming Soon‚Ñ¢</td>
</tr>
<tr>
<td>csvGenerator</td>
<td>Coming Soon‚Ñ¢</td>
</tr>
</tbody>
</table>

<h3>
<a id="details" class="anchor" href="#details" aria-hidden="true"><span class="octicon octicon-link"></span></a>Details</h3>

<p>You can configure what details you want to see in the logs ‚Äì and in what order ‚Äì by providing an array of enum values for each detail supported.  This makes it easy to customize your output format.</p>

<p>The default value includes all available <em>Detail</em> values, in a typical order:</p>

<pre><code>[.Date, .File, .Function, .Category, .Level]
</code></pre>

<p>The inclusion of the logging message is implicit.</p>

<h3>
<a id="configurable-decorators" class="anchor" href="#configurable-decorators" aria-hidden="true"><span class="octicon octicon-link"></span></a>Configurable Decorators</h3>

<p>You can supply a decorator that will further adjust the format of the generator output.  These are configured per destination.  Note: XCodeColors uses ANSI standard format, so you can use that decorator to decorate your file logs too.  Any command line shell will display them correctly.</p>

<table>
<thead>
<tr>
<th>Decorators</th>
<th>Status</th>
<th>Info</th>
</tr>
</thead>
<tbody>
<tr>
<td>XCodeColors (ANSI)</td>
<td>Supported</td>
<td>(<a href="https://github.com/robbiehanson/XcodeColors">https://github.com/robbiehanson/XcodeColors</a>)</td>
</tr>
</tbody>
</table>

<h3>
<a id="configurable-colormaps" class="anchor" href="#configurable-colormaps" aria-hidden="true"><span class="octicon octicon-link"></span></a>Configurable Colormaps</h3>

<p>Make your own color map for mapping <em>Level</em> to color in a platform- and decorator-independent way.  See the <em>ColorMap</em> type for more information.</p>

<h3>
<a id="radioactive-logging" class="anchor" href="#radioactive-logging" aria-hidden="true"><span class="octicon octicon-link"></span></a>Radioactive Logging</h3>

<p>Radioactive logging allows logging to execute based on evaluation of an optional <em>override</em> value at logging sites.  If the <em>override</em> value is non-nil, it is evaluated first. If it is less than or equal to the level of the site, the site will be logged.  If not, logging evaluation will proceed by the normal process.</p>

<p>As an example, imagine you have a <em>Request</em> object base class in a services implementation.  You could define a <em>logOverride</em> property of type <em>Level</em>, defaulting to <em>nil</em>. In the service code that processes requests, you would then provide the value of the <em>logOverride</em> property of requests as the <em>override</em> parameter at all logging sites.  This would cause any non-nil value in requests being processed to be used to override logging for the service.</p>

<p>As a use-case, if you had a service that was processing tons of request, but a specific one was failing in a subtle way, you could use the following procedure to get more information for just that request, as follows:</p>

<ol>
<li>Add code to set a <em>logOverride</em> value (typically .Verbose) where the request is created</li>
<li>Set the <em>activeLevel</em> property in the log instance to <em>.None</em>
</li>
<li>Run your code</li>
</ol>

<p>You would then see logging for <em>only</em> that specific request, at whatever level you specified as the override.  This allows you to focus diagnosis on a particular object as it flows through the system, rather than getting a firehose of logging information for requests that you don't care about if you were to simply set the <em>activeLevel</em> property to a higher value.</p>

<p>This procedure can be done by simply modifying your code at the site of creation of the request, or it can be done by setting a breakpoint at runtime and using the debugger to modify the properties.</p>

<h3>
<a id="categories" class="anchor" href="#categories" aria-hidden="true"><span class="octicon octicon-link"></span></a>Categories</h3>

<p>In addition to the two convenience functions for each level mentioned above, logging sites allow a <em>Category</em> to also be passed to the logging function.  While a category could be any type conforming to the <em>Hashable</em> protocol, you would typically define an <em>enum</em> for type safety.</p>

<p>Once the categories are defined, you can configure your logger to customize the logging level for that category (.Debug or .Verbose, for example), even at runtime.  This allows more fine-tuning of logging if, for example, you want to see more logging of the events for a particular concern (database calls, networking transactions, etc).</p>

<p>The design of <em>Slogger</em> is such that third-party frameworks can expose their log instance and document their category values for developers using the framework.  Then, if the developers need to diagnose a problem inside the framework, they can simply adjust the logging levels for particular categories to get more information.  This is particularly useful in cases where the framework developer doesn't release the source code.</p>

<h2>
<a id="implementing-categories" class="anchor" href="#implementing-categories" aria-hidden="true"><span class="octicon octicon-link"></span></a>Implementing Categories</h2>

<p>Here's an example of how you should implement your custom categories, taken from the unit test code in <em>Slogger</em>.</p>

<p>First, define your category enum:</p>

<pre><code>enum TestCategory : String, SloggerCategory {
  case First, Second

  static func allValues () -&gt; [TestCategory] {
    return [First, Second]
  }
}
</code></pre>

<p>Second, subclass the generic <em>Slogger</em> class to bind it to your category type:</p>

<pre><code>class TestLogger : Slogger&lt;TestCategory&gt; {}
</code></pre>

<p>Then create your logger in the obvious way:</p>

<pre><code>public let log = TestLogger()
</code></pre>

<p>Naturally, if you want your logger to have customized values (generators, decorators, etc.), you can override the <em>init</em> method and provide that information there.</p>

<p><em>Slogger</em> is designed so that all public public properties for a <em>Slogger</em> instance can be modified at runtime, without having to worry about its internal state.</p>

<h2>
<a id="performance" class="anchor" href="#performance" aria-hidden="true"><span class="octicon octicon-link"></span></a>Performance</h2>

<p>Here are initial performance figures for logging calls with a release build (as of version 1.0).  See the <em>SloggerPerformanceIOS</em> project for details.  (Use of <em>Slogger</em> for Mac OS applications should be identical to that of the simulator.)</p>

<table>
<thead>
<tr>
<th>Device</th>
<th>Destinations</th>
<th>Level</th>
<th>log.Debug(.Only, "Message")</th>
</tr>
</thead>
<tbody>
<tr>
<td>Simulator</td>
<td>[MemoryDestination]</td>
<td>.None</td>
<td>363ns</td>
</tr>
<tr>
<td>Simulator</td>
<td>[]</td>
<td>.Severe</td>
<td>363ns</td>
</tr>
<tr>
<td>Simulator</td>
<td>[MemoryDestination]</td>
<td>.Severe</td>
<td>28¬µs</td>
</tr>
<tr>
<td>Simulator</td>
<td>[ConsoleDestination]</td>
<td>.Severe</td>
<td>240¬µs</td>
</tr>
<tr>
<td>iPhone 6</td>
<td>[MemoryDestination]</td>
<td>.None</td>
<td>921ns</td>
</tr>
<tr>
<td>iPhone 6</td>
<td>[]</td>
<td>.Severe</td>
<td>943ns</td>
</tr>
<tr>
<td>iPhone 6</td>
<td>[MemoryDestination]</td>
<td>.Severe</td>
<td>65¬µs</td>
</tr>
<tr>
<td>iPhone 6</td>
<td>[ConsoleDestination]</td>
<td>.Severe</td>
<td>718¬µs</td>
</tr>
</tbody>
</table>

<h2>
<a id="how-to-get-it" class="anchor" href="#how-to-get-it" aria-hidden="true"><span class="octicon octicon-link"></span></a>How To Get it</h2>

<p>Here's how you can get <em>Slogger</em> if you want to give it a try:</p>

<table>
<thead>
<tr>
<th>Means</th>
<th>Status</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>Github</td>
<td>Supported</td>
<td><a href="https://github.com/dgoodine/Slogger">https://github.com/dgoodine/Slogger</a></td>
</tr>
<tr>
<td>Carthage</td>
<td>In process</td>
<td></td>
</tr>
<tr>
<td>Cocoapods</td>
<td>In process</td>
<td>Not a fan of invasive development tools, but it's popular</td>
</tr>
</tbody>
</table>

<h2>
<a id="feedback" class="anchor" href="#feedback" aria-hidden="true"><span class="octicon octicon-link"></span></a>Feedback</h2>

<p>Please do use the issues section on Github report bugs, raise questions, offer suggestions for improvements or ask questions about the implementation.  And if you want to contribute, feel free to discuss it in the issues section and/or issue a pull request.</p>

<p><strong><em>Happy logging!</em></strong></p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Slogger maintained by <a href="https://github.com/dgoodine">dgoodine</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
